# this function implements the main FMA algorithm

# X_train, Y_train, S_train: the training set non-protected features, responses, and sensitive attributes respectively
# fairassist_paras: the hyperparameters for the fairness-assisted stepwise method

# tol_level: the upper bound on the fairness constraint (for dpar only)
# tol_type: the type of the upper bound, correlation or covariance (for dpar only)
# FNR_level: the upper bound on the fairness constraint related to FNR (eopp and eodd only)
# FPR_level: the upper bound on the fairness constraint related to FPR (eodd only)

# sum_to_one: if the weights of all candidate models sum to one
# non_negative: if the weights of all candidate models are non negative
# aic_penalty: whether to include the AIC penalty term

# dccp_paras: the hyperparameters for the dccp solver


FMA <- function(X_train, Y_train, S_train, fairassist_paras, tol_level, tol_type, FNR_level, FPR_level, sum_to_one, non_negative, aic_penalty, dccp_paras){
  
  n_hyper_comb <- length(fairassist_paras$nu_forward_vec)
  
  # each candidate model coverts the original X into a new Z by X %*% beta
  # consider the new Zs generated by all candidate models
  Z_train <- matrix(NA, nrow = nrow(X_train), ncol = 0)
  
  beta_candidate <- matrix(NA, nrow = 0, ncol = (ncol(X_train) + 1))
  list_model <- list()
  spars <- c()
    
  for (i in 1:n_hyper_comb){
    tmp_nu_forward <- fairassist_paras$nu_forward_vec[i]
    tmp_nu_backward <- fairassist_paras$nu_backward_vec[i]
      
    # fit the fairness-assisted stepwise method
    tmp_fit <- fairassist(X = X_train, y = Y_train, ftype = fairassist_paras$ftype, altype = fairassist_paras$altype,
                          G = fairassist_paras$G, eps_obj = fairassist_paras$eps_obj, eps_gdt = fairassist_paras$eps_gdt, maxit = fairassist_paras$maxit,
                          flag = fairassist_paras$flag, nu_forward = tmp_nu_forward, nu_backward = tmp_nu_backward, lambda = fairassist_paras$lambda,
                          fairness = fairassist_paras$fairness, S = S_train, cutoff = fairassist_paras$cutoff, version = fairassist_paras$version, QUIET = fairassist_paras$QUIET)
      
    # the maximum model sparsity to be considered
    max_spars_consider <- min(tmp_fit$maxs, fairassist_paras$num_model_consider)
      
    new_feature_train <- matrix(NA, nrow = nrow(X_train), ncol = (max_spars_consider+1))
    new_beta_candidate <- matrix(NA, nrow = (max_spars_consider + 1), ncol = (ncol(X_train) + 1))
    colnames(new_feature_train) <- paste("Comb: ", i, " NumPred: ", c(0:(max_spars_consider)), sep = "")
    # record the model sparsity of each candidate model
    tmp_spars <- rep(NA, (max_spars_consider+1))
    names(tmp_spars) <- paste("Comb: ", i, " NumPred: ", c(0:(max_spars_consider)), sep = "")
      
    # starts from 2, drop the model with only the intercept
    for (j in 2:(max_spars_consider+1)){
      # check if the model has been considered before
      check_model <- sum(list_model %in% list(tmp_fit$FG[[j]]))

      if (check_model == 0){
        tmp_beta <- tmp_fit$beta[[j]]
        tmp_beta[is.na(tmp_beta)] <- 0
        tmp_beta0 <- tmp_fit$beta0[j]
        # generate the new Z
        new_feature_train[,j] <- as.vector(X_train %*% tmp_beta + rep(tmp_beta0, nrow(X_train)))
        # new beta
        new_beta_candidate[j,] <- c(tmp_beta0, tmp_beta)  
        # number of predictors used by a candidate model
        tmp_spars[j] <- j - 1

        list_model[[length(list_model)+1]] <- tmp_fit$FG[[j]]
      }
    }

    # remove those columns with all NAs
    new_feature_train <- new_feature_train[,colSums(is.na(new_feature_train)) < nrow(new_feature_train)]
    # remove those rows with all NAs
    new_beta_candidate <- new_beta_candidate[rowSums(is.na(new_beta_candidate)) < ncol(new_beta_candidate),]
    # remove NAs from the tmp_spars
    tmp_spars <- tmp_spars[!is.na(tmp_spars)]

    
    Z_train <- cbind(Z_train, new_feature_train)
    beta_candidate <- rbind(beta_candidate, new_beta_candidate)
      
    spars <- c(spars, tmp_spars)
  }

  # fit a glm model to filter out those collinear columns
  V <- factor((Y_train+1)/2, levels = c(0,1))
  filter_mod <- glm(V ~ 1 + Z_train , family = "binomial")
  na_index <- which(is.na(coef(filter_mod))) - 1
    
  if (sum(is.na(coef(filter_mod))) != 0){
    # remove these collinear models
    Z_train <- Z_train[,-na_index]
    beta_candidate <- beta_candidate[-na_index,]  
    spars <- spars[-na_index]
  }
  
  # for equalized odds
  if (fairassist_paras$fairness == "eodd"){
    
    tryCatch({
      if (aic_penalty){
        fair_fit <- ma_eodd(Z_train, Y_train, S_train, dccp_paras$solver_type, dccp_paras$EPS, FNR_level, FPR_level, dccp_paras$tau, dccp_paras$mu, dccp_paras$take_initial_sol, sum_to_one, non_negative, spars, aic_penalty)
      } else{
        fair_fit <- ma_eodd(Z_train, Y_train, S_train, dccp_paras$solver_type, dccp_paras$EPS, FNR_level, FPR_level, dccp_paras$tau, dccp_paras$mu, dccp_paras$take_initial_sol, sum_to_one, non_negative, NULL, aic_penalty)
      }
        
      w <- fair_fit$main$coefficients[-1]
      w_intercept <- fair_fit$main$coefficients[1]
      
      final_beta <- as.vector(w %*% beta_candidate + w_intercept * c(1, rep(0, ncol(beta_candidate) - 1)))
      }, error = function(e){
        cat("The DCCP solver fails", ":", conditionMessage(e), "\n", sep = " ")
      })
    
    return(list(final_beta = final_beta))
  }
  
  
  # for equalized opportunity
  if (fairassist_paras$fairness == "eopp"){
    
    tryCatch({
      if (aic_penalty){
        fair_fit <- ma_eopp(Z_train, Y_train, S_train, dccp_paras$solver_type, dccp_paras$EPS, FNR_level, 10000, dccp_paras$tau, dccp_paras$mu, dccp_paras$take_initial_sol, sum_to_one, non_negative, spars, aic_penalty)
      } else{
        fair_fit <- ma_eopp(Z_train, Y_train, S_train, dccp_paras$solver_type, dccp_paras$EPS, FNR_level, 10000, dccp_paras$tau, dccp_paras$mu, dccp_paras$take_initial_sol, sum_to_one, non_negative, NULL, aic_penalty)
      }
        
      w <- fair_fit$main$coefficients[-1]
      w_intercept <- fair_fit$main$coefficients[1]
      
      final_beta <- as.vector(w %*% beta_candidate + w_intercept * c(1, rep(0, ncol(beta_candidate) - 1)))
      }, error = function(e){
        cat("The DCCP solver fails", ":", conditionMessage(e), "\n", sep = " ")
      })
    
    return(list(final_beta = final_beta))
  }
  
  
  if (fairassist_paras$fairness == "dpar"){
    if (aic_penalty){
      fair_fit <- ma_dpar(Y_train, Z_train, S_train, tol_level, tol_type, sum_to_one, non_negative, spars, aic_penalty)
    } else{
      fair_fit <- ma_dpar(Y_train, Z_train, S_train, tol_level, tol_type, sum_to_one, non_negative, NULL, aic_penalty)
    }
      
    w <- fair_fit$main$coefficients[-1]
    w_intercept <- fair_fit$main$coefficients[1]
    
    final_beta <- as.vector(w %*% beta_candidate + w_intercept * c(1, rep(0, ncol(beta_candidate) - 1)))
      
    return(list(final_beta = final_beta))
  }
}
